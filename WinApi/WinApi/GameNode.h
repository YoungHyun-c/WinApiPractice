#pragma once
#include "GImage.h"

class GameNode
{
private:
	GImage* _backBuffer;
	void setBackBuffer(void);

public:
	virtual HRESULT init(void);
	virtual void release(void);
	virtual void update(void);
	virtual void render(HDC hdc);

	LRESULT MainProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);

	GImage* getBackBuffer() { return _backBuffer; }

	GameNode() : _backBuffer(nullptr){}
	virtual ~GameNode() {}
};

#pragma region 객체지향(OOP)
/*
▶ 객체 지향 프로그래밍 (OOP -> Object Oriented Programing)
-> 기본적으로 코드의 재사용성이 높고 코드의 관리가 용이할 때가 많다.
-> 신뢰성이 높은 프로그래밍을 가능하게 하는 경우 또한 많다.

▶ 객체지향 4대 특징 (순서대로 기억)
1. 캡슐화.
 -> 객체의 속성을 보호하기 위해 사용.

2. 상속.
 -> 객체지향에서의 상속은 하위로 내려갈 수록 구체화 되는 것을 의미한다.
 -> 일반적으로 상속은 재사용성과 확장성이 보장되는 경우가 많기 때문에 사용 빈도가 높다.
 -> 프로그램 구조에 대한 이해도를 향상 시킬 수 있다.
 (선형은 아니지만, 선형처럼 나열되어 있다.)

3. 다형성.
-> 하나의 객체가 여러 형태로 변화하는 것을 의미한다.
ㄴ Overriding

★★★
4. 추상화.
-> 공통적인 부분과 특정 특성을 분리 / 추출해 재조합과 재구성을 하는 행위를 뜻한다.
-> 추상화는 설계 범주에 들어간다. 설계는 경험이 중요함
-> 추상화를 이루기 위해서 상속과 다형성이 들어가야한다.

★★★★★
▶ 객체지향 5대 설계 원칙 (앞 글자를 따라 SOLID 원칙이라고 한다.)
1. SRP (단일 책임의 원칙)
ㄴ 결합도를 낮추고 응집도를 높여야 한다.

＊ 결합도
 - 모듈간의 상호 의존 정도를 나타내고 지표라고 이해하면 좋다.
 - 결합도가 낮으면 상호 의존성이 줄어 재사용 및 유지보수에 유리하다.
 - 로직마다 다르겠지만, 결합도는 로직의 90 ~ 95 % 이상 낮은게 좋다.

 ＊ 응집도
 - 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성이라고 얘기할 수 있다.
 - 응집도가 높은 모듈은 하나의 책임에 집중할 수 있고 독립성이 높아지기 때문에 재사용 및 유지보수에 유리

 ※ 상속 + 오버라이딩을 사용하면 평균 이상은 간다.

 2. OCP (개방 - 폐쇄의 원칙)
 - 자신의 확장에서는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
 -> 상위 클래스 또는 인터페이스를 중간에 두어, 자신의 변화에 대해서는 폐쇄하고 인터페이스는 외부의 변화에 대해 확장성을 개방한다.

 3. LSP (리스코브 치환의 원칙)
 -> 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체 할 수 있어야 한다. (업 캐스팅)
 EX) 상위 : 운송 수단 / 자동차 -> 하위 : 제네시스, BMW

 4. ISP (인터페이스 분리의 원칙)
 -> 클라이언트는 자신이 사용하지 않는 함수 / 매서드에 의존 관계를 맺으면 안된다.
 -> 인터페이스는 각 기능을 분리하여 사용하는 함수 / 매서드에만 의존 관계를 형성한다.
 -> 본인이 만드는 프로젝트 요구 사항과 설계에 따라서 SRP / ISP 중 1개를 선택해야 하는 경우가 많이 발생한다.

 5. DIP (의존관계 역전의 원칙)
 -> 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
 -> 이는 개방폐쇄 원칙에서도 살펴본 내용.
*/
#pragma endregion 

/*
순수 가상 함수

	// Declare Type 순수가상함수
	virtual void IFunctionA() = 0;
	virtual void IFunctionB() = NULL;
	virtual void IFunctionC() = PURE; // 가독성
	virtual void IFunctionD() = abstract; // 가독성
	-> 함수의 구현부가 없고, 선언부가 = 0 으로 끝나는 가상함수를 뜻한다.
	-> 부모 클래스에서 순수 가상함수를 선언하면, 자식클래스에서는 반드시 재정의한 함수를 멤버로 가져야 한다.
	-> 메모리랑 연산량을 줄이기 위해, 상위 쪽에 하나를 잡아두고 내리는 개념.

▶추상 클래스
-> 순수 가상함수가 1개 이상 있는 클래스를 뜻한다.
▷특징
-> 객체를 생성할 수 없다.
-> 포인터 변수는 만들 수 있다.
-> 추상 클래스로 지정한 객체는 인스턴스를 만들 수 없다.
-> 추상 클래스의 자식 클래스를 통해 인스턴스를 생성할 수 있다.
-> 키워드는 abstract
-> 멤버 변수 또는 일반 멤버 함수가 포함된 여부와 상관없이 순수 가상함수를 1개 이상 가지고 있는 클래스는 추상클래스라고 할 수 있다.

class A abstract
{

}

▶인터페이스
-> 순수 가상함수로만 이루어진 클래스 -> 인터페이스
-> 인터페이스의 개념은 하위 클래스에서 반드시 정의해야 할 함수를 정해주는 클래스라고 할 수 있다.
-> C++ 에는 인터페이스라는 개념을 공식적인 키워드로 지원하지 않는다.
-> 표기법 : 파스칼 케이스.
EX:
Interface (순수 가상함수 설계) -> 상속 -> abstract -> 상속 -> 기본 클래스
개발기간이 짧거나, 간단한 경우는 인터페이스가 직접 상속받는 경우가 있음.
반면, Interface가 없는데 abstract에서 직접 기본 클래스로 상속하는 경우는 없음.

▷특징
-> 멤버 변수 / 함수를 포함 시킬 수 없다. (정적 함수)
-> 한정자를 사용할 수 없다.
-> 기본 클래스를 상속 받을 수 없다.
-> 생성 / 소멸 / 연산 포함이 될 수 없다.
-> 일반적으로 public 속성을 가지고 있어야 한다.

▶ 장점
-> 다중 상속 (상속관계에서 다이아몬드 구조 : 장점 없음(상속 단계가 줄어 속도는 빠를 수 있음).
	ㄴ 왠만하면 다시 만들어라. 1 모호성, 2 include 순서, 3. 중첩화 문제.

-> 다형성
▶ 단점
-> 가독성이 떨어진다. (실제 구현 레벨로 가야 알 수 있으므로)
-> C++ 강제성이 없기 때문에 프로그래머에 의한 실수가 발생할 여지가 아주 많다.

★★★
▶가상 소멸자 (상속에서는 쓰지마라)
남발 금지, 퍼포먼스 이슈가 있음 (반드시 적재적소로 넣는다. 애매하면 virtual로 넣는다. 퍼포먼스 < 프로그램 살리기)
 -> 인터페이스, 추상 클래스, 가상 함수 등에서 동적 할당 된 클래스를 메모리 해제하면, 자식 클래스의 소멸자를 호출해야 되는데
 부모 클래스의 소멸자만 호출이 되는 문제를 해결할 수 있다.
 
 -> 호출 순서에 의한 문제를 해결하기 위해 가상 소멸자를 사용해야 한다.
 -> 이는 매모리 순환 및 잠재적인 오류에 대한 문제점을 방지할 수 있다.
 -> 다만 클래스 링크 / 호출 절차에 의한 속도 및 퍼포먼스 이슈가 발생 할 여지가 생기니
 사용할 때는 주의를 해주면 좋다. -> 쓰면 일단 본전은 칠 수 있다.

 자식 클래스 객체 생성 과정
 1. 부모 클래스의 cpp확인 -> h헤더
 2. 부모클래스의 선언부 확인 (virtual 키워드가 있는가)
 3. 부모클래스의 생성자 호출
 4. delete 호출시 부모 먼저 확인.
*/
